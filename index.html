<!DOCTYPE html>
<html lang="en" class="bg-blue-00">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=no"
    />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta
      name="apple-mobile-web-app-status-bar-style"
      content="black-translucent"
    />
    <meta name="theme-color" content="#1E3A8A" />
    <title>RunItUp</title>
    <link rel="manifest" href="/manifest.json" />
    <link rel="apple-touch-icon" href="/icons/hermes-bootcopy.PNG" />
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/gsap.min.js"></script>
    <style>
      html {
        background-color: #1e3a8a; /* Sets the overscroll color */
      }
      body {
        overscroll-behavior: none; /* Prevents overscroll bounce on iOS */
        -webkit-overflow-scrolling: touch; /* Enables smooth scrolling on iOS */
      }
      .safe-area-inset {
        padding-top: env(safe-area-inset-top);
        padding-bottom: env(safe-area-inset-bottom);
        padding-left: env(safe-area-inset-left);
        padding-right: env(safe-area-inset-right);
      }
      button {
        transition: transform 0.1s;
      }
      button:active {
        transform: scale(0.95);
      }
      input {
        font-family: -apple-system, sans-serif;
        border: 1px solid #ccc;
        border-radius: 8px;
      }
      /* Optional: Add a class for animating the container of the stats for a subtle overall bounce */
      .stat-card-bounce {
        will-change: transform, opacity;
      }
    </style>
  </head>
  <body class="min-h-screen font-sans">
    <div
      id="app"
      class="w-full max-w-md mx-auto px-6 py-3 flex-1 flex flex-col justify-between safe-area-inset"
    >
      <div>
        <div class="text-center mb-3">
          <img
            src="/icons/boot.svg"
            alt="RunItUp Logo"
            class="w-full max-w-[120px] h-auto mx-auto"
          />
        </div>
        <div
          class="bg-white bg-opacity-10 p-6 rounded-lg shadow-lg mb-6 stat-card-bounce"
          ref="statsCard"
        >
          <h2 class="text-2xl font-semibold mb-2 text-white">Stats</h2>
          <p class="text-lg text-white">
            Total Distance: {{ animatedTotalDistance.toFixed(2) }} miles
          </p>
          <p class="text-lg text-white">
            Total Time: {{ formatTime(animatedTotalTime, true) }}
          </p>
          <p class="text-lg text-white">XP: {{ Math.floor(animatedXp) }}</p>
          <div class="mt-4">
            <div class="flex items-center mb-2">
              <span class="text-2xl mr-2">{{ currentLevel.emoji }}</span>
              <span class="text-lg font-semibold text-white"
                >Level: {{ currentLevel.name }}</span
              >
            </div>
            <div class="w-full bg-gray-300 rounded-full h-4">
              <div
                class="bg-yellow-300 h-4 rounded-full"
                :style="{ width: progress + '%' }"
              ></div>
            </div>
            <p class="text-sm mt-1 text-white">
              {{ Math.floor(xp) }} / {{ currentLevel.xp === Infinity ? '‚àû' :
              currentLevel.xp }} XP{{ nextLevel.name !== currentLevel.name ? `
              to ${nextLevel.emoji} ${nextLevel.name}` : '' }}
            </p>
          </div>
        </div>
        <div class="bg-white bg-opacity-10 p-6 rounded-lg shadow-lg mb-6">
          <h2 class="text-2xl font-semibold mb-4 text-white">Start Workout</h2>
          <button
            :disabled="isTracking"
            @click="startWorkout"
            class="w-full p-3 bg-yellow-300 text-gray-800 font-semibold rounded-lg hover:bg-yellow-400 transition active:bg-yellow-500"
            :class="{ 'opacity-50 cursor-not-allowed': isTracking }"
          >
            {{ isTracking ? 'Tracking...' : 'Start Workout' }}
          </button>
          <div v-if="isTracking" class="mt-4">
            <p class="text-lg text-white">
              Current Distance: {{ currentDistance.toFixed(2) }} miles
            </p>
            <p class="text-lg text-white">
              Pace: {{ formatTime(currentPace) }}
            </p>
            <button
              @click="stopWorkout"
              class="w-full p-3 bg-red-500 text-white font-semibold rounded-lg hover:bg-red-600 transition active:bg-red-700"
            >
              Stop Workout
            </button>
          </div>
        </div>
        <div class="bg-white bg-opacity-10 p-6 rounded-lg shadow-lg mb-6">
          <h2 class="text-2xl font-semibold mb-4 text-white">Log a Run</h2>
          <div>
            <input
              v-model.number="distanceInput"
              type="number"
              step="0.01"
              placeholder="Distance (miles)"
              class="w-full p-3 mb-4 rounded-lg bg-gray-100 text-gray-800 focus:outline-none"
            />
            <div class="flex space-x-2 mb-4">
              <input
                v-model.number="hoursInput"
                type="number"
                placeholder="Hours"
                class="w-1/3 p-3 rounded-lg bg-gray-100 text-gray-800 focus:outline-none"
                min="0"
              />
              <input
                v-model.number="minutesInput"
                type="number"
                placeholder="Minutes"
                class="w-1/3 p-3 rounded-lg bg-gray-100 text-gray-800 focus:outline-none"
                min="0"
                max="59"
              />
              <input
                v-model.number="secondsInput"
                type="number"
                placeholder="Seconds"
                class="w-1/3 p-3 rounded-lg bg-gray-100 text-gray-800 focus:outline-none"
                min="0"
                max="59"
              />
            </div>
            <button
              @click="logRun"
              class="w-full p-3 bg-yellow-300 text-gray-800 font-semibold rounded-lg hover:bg-yellow-400 transition active:bg-yellow-500"
            >
              Log Run
            </button>
          </div>
        </div>

        <div
          v-if="runHistory.length > 0"
          class="bg-white bg-opacity-10 p-6 rounded-lg shadow-lg mb-6"
        >
          <h2 class="text-2xl font-semibold mb-4 text-white">Run History</h2>
          <ul>
            <li
              v-for="(run, index) in runHistory"
              :key="index"
              class="mb-2 text-white border-b border-gray-400 pb-2 last:border-b-0"
            >
              <p class="text-lg">
                <strong>Date:</strong> {{ new
                Date(run.date).toLocaleDateString() }}
              </p>
              <p class="text-lg">
                <strong>Distance:</strong> {{ run.distance.toFixed(2) }} miles
              </p>
              <p class="text-lg">
                <strong>Time:</strong> {{ formatTime(run.time, true) }}
              </p>
              <p class="text-lg">
                <strong>Pace:</strong> {{ formatTime(run.pace) }} per mile
              </p>
              <button
                @click="deleteRun(index)"
                class="mt-2 px-3 py-1 bg-red-500 text-white text-sm font-semibold rounded-lg hover:bg-red-600 transition active:bg-red-700"
              >
                Delete Run
              </button>
            </li>
          </ul>
        </div>
      </div>
      <div class="bg-white bg-opacity-10 p-6 rounded-lg shadow-lg mb-6">
        <h2 class="text-2xl font-semibold mb-4 text-white">Reset Progress</h2>
        <button
          @click="resetStats"
          class="w-full p-3 bg-red-500 text-white font-semibold rounded-lg hover:bg-red-600 transition active:bg-red-700"
        >
          Reset Stats
        </button>
      </div>
      <footer class="text-center text-sm mt-6 mb-4 text-white">
        ¬© 2025 RunItUp. All rights reserved.
      </footer>
    </div>
    <script>
      function showInstallPrompt() {
        if (
          navigator.userAgent.match(/iPhone|iPad|iPod/i) &&
          !window.matchMedia("(display-mode: standalone)").matches
        ) {
          alert(
            "To install RunItUp, tap the Share icon and select 'Add to Home Screen'."
          );
        }
      }
      if ("serviceWorker" in navigator) {
        window.addEventListener("load", () => {
          setTimeout(showInstallPrompt, 5000); // Show after 5 seconds
          navigator.serviceWorker.register("/sw.js").then(
            (reg) => console.log("Service Worker registered", reg),
            (err) => console.error("Service Worker registration failed", err)
          );
        });
      }
      const { createApp, nextTick } = Vue;

      const levels = [
        { name: "Bronze", emoji: "ü•â", xp: 25 },
        { name: "Silver", emoji: "ü•à", xp: 50 },
        { name: "Gold", emoji: "ü•á", xp: 100 },
        { name: "Platinum", emoji: "‚ö™", xp: 200 },
        { name: "Emerald", emoji: "‚ùáÔ∏è", xp: 400 },
        { name: "Sapphire", emoji: "üî∑", xp: 800 },
        { name: "Ruby", emoji: "‚ô¶Ô∏è", xp: 1600 },
        { name: "Diamond", emoji: "üíé", xp: 3200 },
        { name: "Onyx", emoji: "‚ö´", xp: 6400 },
        { name: "Obsidian", emoji: "üñ§", xp: 12800 },
        { name: "Mythic", emoji: "üåü", xp: 25600 },
        { name: "Legendary", emoji: "üèÜ", xp: Infinity }, // Last level with infinite XP
      ];

      createApp({
        data() {
          return {
            levels: levels,
            totalDistance:
              parseFloat(localStorage.getItem("totalDistance")) || 0,
            totalTime: parseFloat(localStorage.getItem("totalTime")) || 0,
            xp: parseFloat(localStorage.getItem("xp")) || 0,

            animatedTotalDistance:
              parseFloat(localStorage.getItem("totalDistance")) || 0,
            animatedTotalTime:
              parseFloat(localStorage.getItem("totalTime")) || 0,
            animatedXp: parseFloat(localStorage.getItem("xp")) || 0,

            isTracking: false,
            watchId: null,
            startTime: null,
            lastPosition: null,
            currentDistance: 0,
            currentPace: 0,
            distanceInput: null,
            hoursInput: null,
            minutesInput: null,
            secondsInput: null,
            runHistory: JSON.parse(localStorage.getItem("runHistory")) || [],
          };
        },
        computed: {
          currentLevel() {
            for (let i = 0; i < this.levels.length; i++) {
              if (this.xp <= this.levels[i].xp)
                return { ...this.levels[i], index: i };
            }
            return this.levels[this.levels.length - 1];
          },
          nextLevel() {
            return this.levels[
              Math.min(this.currentLevel.index + 1, this.levels.length - 1)
            ];
          },
          progress() {
            const prevLevel = this.levels[this.currentLevel.index - 1] || {
              xp: 0,
            };
            return this.currentLevel.xp === Infinity
              ? 100
              : ((this.xp - prevLevel.xp) /
                  (this.currentLevel.xp - prevLevel.xp)) *
                  100;
          },
        },
        methods: {
          formatTime(seconds, includeHours = false) {
            if (seconds === 0 || isNaN(seconds)) return "00:00";
            const hrs = Math.floor(seconds / 3600);
            const mins = Math.floor((seconds % 3600) / 60);
            const secs = Math.floor(seconds % 60);
            if (includeHours || hrs > 0) {
              return `${hrs.toString().padStart(2, "0")}:${mins
                .toString()
                .padStart(2, "0")}:${secs.toString().padStart(2, "0")}`;
            }
            return `${mins.toString().padStart(2, "0")}:${secs
              .toString()
              .padStart(2, "0")}`;
          },
          calculateDistance(lat1, lon1, lat2, lon2) {
            const R = 3958.8; // Radius of Earth in miles
            const dLat = ((lat2 - lat1) * Math.PI) / 180;
            const dLon = ((lon2 - lon1) * Math.PI) / 180;
            const a =
              Math.sin(dLat / 2) * Math.sin(dLat / 2) +
              Math.cos((lat1 * Math.PI) / 180) *
                Math.cos((lat2 * Math.PI) / 180) *
                Math.sin(dLon / 2) *
                Math.sin(dLon / 2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
            return R * c;
          },
          startWorkout() {
            if ("vibrate" in navigator) navigator.vibrate(50);
            if (!this.isTracking && navigator.geolocation) {
              this.isTracking = true;
              this.startTime = Date.now();
              this.currentDistance = 0;
              this.lastPosition = null;
              this.watchId = navigator.geolocation.watchPosition(
                (position) => {
                  const { latitude, longitude } = position.coords;
                  if (this.lastPosition) {
                    const dist = this.calculateDistance(
                      this.lastPosition.latitude,
                      this.lastPosition.longitude,
                      latitude,
                      longitude
                    );
                    this.currentDistance += dist;
                  }
                  this.lastPosition = { latitude, longitude };
                  const elapsedSeconds = (Date.now() - this.startTime) / 1000;
                  this.currentPace =
                    this.currentDistance > 0
                      ? elapsedSeconds / this.currentDistance
                      : 0;
                },
                (error) => {
                  alert("Geolocation error: " + error.message);
                  this.stopWorkout();
                },
                { enableHighAccuracy: true, maximumAge: 0, timeout: 15000 }
              );
            } else if (!navigator.geolocation) {
              alert("Geolocation is not supported by this browser.");
            }
          },
          async stopWorkout() {
            if ("vibrate" in navigator) navigator.vibrate(50);
            if (this.watchId) {
              navigator.geolocation.clearWatch(this.watchId);
            }
            this.isTracking = false;
            if (this.currentDistance > 0) {
              const workoutTime = (Date.now() - this.startTime) / 1000;
              const oldTotalDistance = this.totalDistance;
              const oldTotalTime = this.totalTime;
              const oldXp = this.xp;

              this.totalDistance += this.currentDistance;
              this.xp += this.currentDistance;
              this.totalTime += workoutTime;

              this.animateStat(
                "totalDistance",
                oldTotalDistance,
                this.totalDistance
              );
              this.animateStat("totalTime", oldTotalTime, this.totalTime);
              this.animateStat("xp", oldXp, this.xp);

              this.runHistory.unshift({
                date: new Date().toISOString(),
                distance: this.currentDistance,
                time: workoutTime,
                pace: workoutTime / this.currentDistance,
              });

              this.saveToLocalStorage();

              await nextTick();
              this.scrollToTop(); // Changed to scroll to top

              if (Notification.permission === "granted") {
                new Notification("Workout Complete!", {
                  body: `You ran ${this.currentDistance.toFixed(2)} miles!`,
                  icon: "/icons/boot.svg",
                });
              } else if (Notification.permission !== "denied") {
                Notification.requestPermission();
              }
            }
            this.currentDistance = 0;
            this.currentPace = 0;
            this.lastPosition = null;
            this.startTime = null;
          },
          async logRun() {
            if ("vibrate" in navigator) navigator.vibrate(50);
            const dist = parseFloat(this.distanceInput);
            const hours = parseInt(this.hoursInput) || 0;
            const minutes = parseInt(this.minutesInput) || 0;
            const seconds = parseInt(this.secondsInput) || 0;
            const timeInSeconds = hours * 3600 + minutes * 60 + seconds;

            if (dist > 0 && timeInSeconds > 0) {
              const oldTotalDistance = this.totalDistance;
              const oldTotalTime = this.totalTime;
              const oldXp = this.xp;

              this.totalDistance += dist;
              this.totalTime += timeInSeconds;
              this.xp += dist;

              this.animateStat(
                "totalDistance",
                oldTotalDistance,
                this.totalDistance
              );
              this.animateStat("totalTime", oldTotalTime, this.totalTime);
              this.animateStat("xp", oldXp, this.xp);

              this.runHistory.unshift({
                date: new Date().toISOString(),
                distance: dist,
                time: timeInSeconds,
                pace: timeInSeconds / dist,
              });

              this.distanceInput = null;
              this.hoursInput = null;
              this.minutesInput = null;
              this.secondsInput = null;
              this.saveToLocalStorage();

              await nextTick();
              this.scrollToTop(); // Changed to scroll to top
            } else {
              alert(
                "Please enter a valid distance (miles) and time (all fields)."
              );
            }
          },
          async deleteRun(index) {
            if (confirm("Are you sure you want to delete this run?")) {
              const runToDelete = this.runHistory[index];

              const oldTotalDistance = this.totalDistance;
              const oldTotalTime = this.totalTime;
              const oldXp = this.xp;

              this.totalDistance -= runToDelete.distance;
              this.totalTime -= runToDelete.time;
              this.xp -= runToDelete.distance;

              this.animateStat(
                "totalDistance",
                oldTotalDistance,
                this.totalDistance
              );
              this.animateStat("totalTime", oldTotalTime, this.totalTime);
              this.animateStat("xp", oldXp, this.xp);

              this.runHistory.splice(index, 1);

              this.saveToLocalStorage();

              await nextTick();
              this.scrollToTop(); // Changed to scroll to top

              if ("vibrate" in navigator) navigator.vibrate(50);
            }
          },

          animateStat(statName, startValue, endValue) {
            let animatedPropName;
            if (statName === "totalDistance")
              animatedPropName = "animatedTotalDistance";
            else if (statName === "totalTime")
              animatedPropName = "animatedTotalTime";
            else if (statName === "xp") animatedPropName = "animatedXp";
            else return;

            gsap.killTweensOf(this[animatedPropName]);

            gsap.fromTo(
              this.$data,
              { [animatedPropName]: startValue },
              {
                [animatedPropName]: endValue,
                duration: 1.5,
                ease: "elastic.out(1, 0.5)",
              }
            );

            // The stats card is still referenced for its individual bounce animation
            gsap.fromTo(
              this.$refs.statsCard,
              { scale: 1, y: 0 },
              {
                scale: 1.02,
                y: -5,
                duration: 0.2,
                ease: "power1.out",
                yoyo: true,
                repeat: 1,
              }
            );
          },

          // --- MODIFIED scroll method to scroll to top ---
          scrollToTop() {
            // nextTick ensures the DOM is fully updated before scrolling
            this.$nextTick(() => {
              window.scrollTo({
                top: 0, // Scroll to the very top of the page
                behavior: "smooth", // Smooth scrolling animation
              });
            });
          },
          // --- End MODIFIED scroll method ---

          saveToLocalStorage() {
            localStorage.setItem("totalDistance", this.totalDistance);
            localStorage.setItem("totalTime", this.totalTime);
            localStorage.setItem("xp", this.xp);
            localStorage.setItem("runHistory", JSON.stringify(this.runHistory));
          },
          async resetStats() {
            if (confirm("Are you sure you want to reset all stats?")) {
              const oldTotalDistance = this.totalDistance;
              const oldTotalTime = this.totalTime;
              const oldXp = this.xp;

              this.totalDistance = 0;
              this.totalTime = 0;
              this.xp = 0;
              this.runHistory = [];

              this.animateStat("totalDistance", oldTotalDistance, 0);
              this.animateStat("totalTime", oldTotalTime, 0);
              this.animateStat("xp", oldXp, 0);

              this.saveToLocalStorage();

              await nextTick();
              this.scrollToTop(); // Changed to scroll to top

              if ("vibrate" in navigator) navigator.vibrate(100);
            }
          },
        },
        mounted() {
          this.animatedTotalDistance = this.totalDistance;
          this.animatedTotalTime = this.totalTime;
          this.animatedXp = this.xp;

          this.saveToLocalStorage();
          if (
            Notification.permission !== "granted" &&
            Notification.permission !== "denied"
          ) {
            Notification.requestPermission();
          }
        },
      }).mount("#app");
    </script>
  </body>
</html>
