<!DOCTYPE html>
<html lang="en" class="bg-blue-00">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=no"
    />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta
      name="apple-mobile-web-app-status-bar-style"
      content="black-translucent"
    />
    <meta name="theme-color" content="#1E3A8A" />
    <title>RunItUp</title>
    <link rel="manifest" href="/manifest.json" />
    <link rel="apple-touch-icon" href="/icons/hermes-bootcopy.PNG" />
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/gsap.min.js"></script>

    <style>
      html {
        background-color: #1e3a8a; /* Sets the overscroll color */
      }
      body {
        overscroll-behavior: none; /* Prevents overscroll bounce on iOS */
        -webkit-overflow-scrolling: touch; /* Enables smooth scrolling on iOS */
      }
      .safe-area-inset {
        padding-top: env(safe-area-inset-top);
        padding-bottom: env(safe-area-inset-bottom);
        padding-left: env(safe-area-inset-left);
        padding-right: env(safe-area-inset-right);
      }
      button {
        transition: transform 0.1s;
      }
      button:active {
        transform: scale(0.95);
      }
      input {
        font-family: -apple-system, sans-serif;
        border: 1px solid #ccc;
        border-radius: 8px;
      }
      /* Optional: Add a class for animating the container of the stats for a subtle overall bounce */
      .stat-card-bounce {
        will-change: transform, opacity;
      }
    </style>
  </head>
  <body class="min-h-screen font-sans">
    <div
      id="app"
      class="w-full max-w-md mx-auto px-6 py-3 flex-1 flex flex-col justify-between safe-area-inset"
    >
      <div
        v-if="!user"
        class="bg-white bg-opacity-10 p-6 rounded-lg shadow-lg mb-6 text-white"
      >
        <h2 class="text-2xl font-semibold mb-4">Account</h2>
        <input
          type="email"
          v-model="email"
          placeholder="Email"
          class="w-full p-3 mb-3 rounded-lg bg-gray-100 text-gray-800 focus:outline-none"
        />
        <input
          type="password"
          v-model="password"
          placeholder="Password"
          class="w-full p-3 mb-4 rounded-lg bg-gray-100 text-gray-800 focus:outline-none"
        />
        <button
          @click="handleSignIn"
          class="w-full p-3 bg-blue-500 text-white font-semibold rounded-lg hover:bg-blue-600 transition active:bg-blue-700 mb-2"
        >
          Sign In
        </button>
        <button
          @click="handleSignUp"
          class="w-full p-3 bg-green-500 text-white font-semibold rounded-lg hover:bg-green-600 transition active:bg-green-700"
        >
          Sign Up
        </button>
        <p v-if="authMessage" class="mt-4 text-center text-sm">
          {{ authMessage }}
        </p>
      </div>

      <div
        v-if="user"
        class="bg-white bg-opacity-10 p-6 rounded-lg shadow-lg mb-6 text-white text-center"
      >
        <h2 class="text-2xl font-semibold mb-2">Welcome, {{ user.email }}!</h2>
        <button
          @click="handleSignOut"
          class="w-full p-3 bg-red-500 text-white font-semibold rounded-lg hover:bg-red-600 transition active:bg-red-700"
        >
          Sign Out
        </button>
      </div>

      <div>
        <div class="text-center mb-3">
          <img
            src="/icons/boot.svg"
            alt="RunItUp Logo"
            class="w-full max-w-[120px] h-auto mx-auto"
          />
        </div>
        <div
          class="bg-white bg-opacity-10 p-6 rounded-lg shadow-lg mb-6 stat-card-bounce"
          ref="statsCard"
        >
          <h2 class="text-2xl font-semibold mb-2 text-white">Stats</h2>
          <p class="text-lg text-white">
            Total Distance: {{ animatedTotalDistance.toFixed(2) }} miles
          </p>
          <p class="text-lg text-white">
            Total Time: {{ formatTime(animatedTotalTime, true) }}
          </p>
          <p class="text-lg text-white">XP: {{ Math.floor(animatedXp) }}</p>
          <div class="mt-4">
            <div class="flex items-center mb-2">
              <span class="text-2xl mr-2">{{ currentLevel.emoji }}</span>
              <span class="text-lg font-semibold text-white"
                >Level: {{ currentLevel.name }}</span
              >
            </div>
            <div class="w-full bg-gray-300 rounded-full h-4">
              <div
                class="bg-yellow-300 h-4 rounded-full"
                :style="{ width: progress + '%' }"
              ></div>
            </div>
            <p class="text-sm mt-1 text-white">
              {{ Math.floor(xp) }} / {{ currentLevel.xp === Infinity ? '‚àû' :
              currentLevel.xp }} XP{{ nextLevel.name !== currentLevel.name ? `
              to ${nextLevel.emoji} ${nextLevel.name}` : '' }}
            </p>
          </div>
        </div>
        <div class="bg-white bg-opacity-10 p-6 rounded-lg shadow-lg mb-6">
          <h2 class="text-2xl font-semibold mb-4 text-white">Start Workout</h2>
          <button
            :disabled="isTracking"
            @click="startWorkout"
            class="w-full p-3 bg-yellow-300 text-gray-800 font-semibold rounded-lg hover:bg-yellow-400 transition active:bg-yellow-500"
            :class="{ 'opacity-50 cursor-not-allowed': isTracking }"
          >
            {{ isTracking ? 'Tracking...' : 'Start Workout' }}
          </button>
          <div v-if="isTracking" class="mt-4">
            <p class="text-lg text-white">
              Current Distance: {{ currentDistance.toFixed(2) }} miles
            </p>
            <p class="text-lg text-white">
              Pace: {{ formatTime(currentPace) }}
            </p>
            <button
              @click="stopWorkout"
              class="w-full p-3 bg-red-500 text-white font-semibold rounded-lg hover:bg-red-600 transition active:bg-red-700"
            >
              Stop Workout
            </button>
          </div>
        </div>
        <div class="bg-white bg-opacity-10 p-6 rounded-lg shadow-lg mb-6">
          <h2 class="text-2xl font-semibold mb-4 text-white">Log a Run</h2>
          <div>
            <input
              v-model.number="distanceInput"
              type="number"
              step="0.01"
              placeholder="Distance (miles)"
              class="w-full p-3 mb-4 rounded-lg bg-gray-100 text-gray-800 focus:outline-none"
            />
            <div class="flex space-x-2 mb-4">
              <input
                v-model.number="hoursInput"
                type="number"
                placeholder="Hours"
                class="w-1/3 p-3 rounded-lg bg-gray-100 text-gray-800 focus:outline-none"
                min="0"
              />
              <input
                v-model.number="minutesInput"
                type="number"
                placeholder="Minutes"
                class="w-1/3 p-3 rounded-lg bg-gray-100 text-gray-800 focus:outline-none"
                min="0"
                max="59"
              />
              <input
                v-model.number="secondsInput"
                type="number"
                placeholder="Seconds"
                class="w-1/3 p-3 rounded-lg bg-gray-100 text-gray-800 focus:outline-none"
                min="0"
                max="59"
              />
            </div>
            <button
              @click="logRun"
              class="w-full p-3 bg-yellow-300 text-gray-800 font-semibold rounded-lg hover:bg-yellow-400 transition active:bg-yellow-500"
            >
              Log Run
            </button>
          </div>
        </div>
        <div
          v-if="runHistory.length > 0"
          class="bg-white bg-opacity-10 p-6 rounded-lg shadow-lg mb-6"
        >
          <h2 class="text-2xl font-semibold mb-4 text-white">Run History</h2>
          <ul>
            <li
              v-for="(run, index) in runHistory"
              :key="index"
              class="mb-2 text-white border-b border-gray-400 pb-2 last:border-b-0"
            >
              <p class="text-lg">
                <strong>Date:</strong> {{ new
                Date(run.date).toLocaleDateString() }}
              </p>
              <p class="text-lg">
                <strong>Distance:</strong> {{ run.distance.toFixed(2) }} miles
              </p>
              <p class="text-lg">
                <strong>Time:</strong> {{ formatTime(run.time, true) }}
              </p>
              <p class="text-lg">
                <strong>Pace:</strong> {{ formatTime(run.pace) }} per mile
              </p>
              <button
                @click="deleteRun(index)"
                class="mt-2 px-3 py-1 bg-red-500 text-white text-sm font-semibold rounded-lg hover:bg-red-600 transition active:bg-red-700"
              >
                Delete Run
              </button>
            </li>
          </ul>
        </div>
      </div>
      <div class="bg-white bg-opacity-10 p-6 rounded-lg shadow-lg mb-6">
        <h2 class="text-2xl font-semibold mb-4 text-white">Reset Progress</h2>
        <button
          @click="resetStats"
          class="w-full p-3 bg-red-500 text-white font-semibold rounded-lg hover:bg-red-600 transition active:bg-red-700"
        >
          Reset Stats
        </button>
      </div>
      <footer class="text-center text-sm mt-6 mb-4 text-white">
        ¬© 2025 RunItUp. All rights reserved.
      </footer>
    </div>

    <script type="module">
      // ALL Firebase imports should be at the top of this main script block
      import {
        auth,
        db,
        onAuthStateChanged,
        signOut,
        createUserWithEmailAndPassword,
        signInWithEmailAndPassword,
        collection,
        addDoc,
        query,
        where,
        getDocs,
        deleteDoc,
        doc,
        setDoc,
        updateDoc,
        writeBatch, // Make sure writeBatch is also exported from firebase-config.js
        getDoc, // Ensure getDoc is imported for single document fetches
      } from "./firebase-config.js";

      function showInstallPrompt() {
        if (
          navigator.userAgent.match(/iPhone|iPad|iPod/i) &&
          !window.matchMedia("(display-mode: standalone)").matches
        ) {
          alert(
            "To install RunItUp, tap the Share icon and select 'Add to Home Screen'."
          );
        }
      }
      if ("serviceWorker" in navigator) {
        window.addEventListener("load", () => {
          setTimeout(showInstallPrompt, 5000); // Show after 5 seconds
          navigator.serviceWorker.register("/sw.js").then(
            (reg) => console.log("Service Worker registered", reg),
            (err) => console.error("Service Worker registration failed", err)
          );
        });
      }
      const { createApp, nextTick } = Vue;

      const levels = [
        { name: "Bronze", emoji: "ü•â", xp: 25 },
        { name: "Silver", emoji: "ü•à", xp: 50 },
        { name: "Gold", emoji: "ü•á", xp: 100 },
        { name: "Platinum", emoji: "‚ö™", xp: 200 },
        { name: "Emerald", emoji: "‚ùáÔ∏è", xp: 400 },
        { name: "Sapphire", emoji: "üî∑", xp: 800 },
        { name: "Ruby", emoji: "‚ô¶Ô∏è", xp: 1600 },
        { name: "Diamond", emoji: "üíé", xp: 3200 },
        { name: "Onyx", emoji: "‚ö´", xp: 6400 },
        { name: "Obsidian", emoji: "üñ§", xp: 12800 },
        { name: "Mythic", emoji: "üåü", xp: 25600 },
        { name: "Legendary", emoji: "üèÜ", xp: Infinity }, // Last level with infinite XP
      ];

      createApp({
        data() {
          return {
            levels: levels,
            user: null, // Holds the authenticated Firebase user object
            email: "",
            password: "",
            authMessage: "", // To display authentication messages (errors/success)
            totalDistance: 0, // Will be loaded from Firestore
            totalTime: 0, // Will be loaded from Firestore
            xp: 0, // Will be loaded from Firestore

            animatedTotalDistance: 0, // Will be initialized with Firestore data
            animatedTotalTime: 0, // Will be initialized with Firestore data
            animatedXp: 0, // Will be initialized with Firestore data

            isTracking: false,
            watchId: null,
            startTime: null,
            lastPosition: null,
            currentDistance: 0,
            currentPace: 0,
            distanceInput: null,
            hoursInput: null,
            minutesInput: null,
            secondsInput: null,
            runHistory: [], // Will be loaded from Firestore
          };
        },
        computed: {
          currentLevel() {
            for (let i = 0; i < this.levels.length; i++) {
              if (this.xp <= this.levels[i].xp)
                return { ...this.levels[i], index: i };
            }
            return this.levels[this.levels.length - 1];
          },
          nextLevel() {
            return this.levels[
              Math.min(this.currentLevel.index + 1, this.levels.length - 1)
            ];
          },
          progress() {
            const prevLevel = this.levels[this.currentLevel.index - 1] || {
              xp: 0,
            };
            return this.currentLevel.xp === Infinity
              ? 100
              : ((this.xp - prevLevel.xp) /
                  (this.currentLevel.xp - prevLevel.xp)) *
                  100;
          },
        },
        methods: {
          // --- NEW AUTHENTICATION METHODS ---
          async handleSignUp() {
            this.authMessage = ""; // Clear previous messages
            try {
              const userCredential = await createUserWithEmailAndPassword(
                auth,
                this.email,
                this.password
              );
              this.user = userCredential.user;
              this.authMessage = "Signed up successfully!";
              this.email = "";
              this.password = "";
              // No need to fetch runs immediately here; onAuthStateChanged will handle it.
            } catch (error) {
              this.authMessage = `Error signing up: ${error.message}`;
              console.error("Sign up error:", error);
            }
          },

          async handleSignIn() {
            this.authMessage = ""; // Clear previous messages
            try {
              const userCredential = await signInWithEmailAndPassword(
                auth,
                this.email,
                this.password
              );
              this.user = userCredential.user;
              this.authMessage = "Signed in successfully!";
              this.email = "";
              this.password = "";
              // No need to fetch runs immediately here; onAuthStateChanged will handle it.
            } catch (error) {
              this.authMessage = `Error signing in: ${error.message}`;
              console.error("Sign in error:", error);
            }
          },

          async handleSignOut() {
            this.authMessage = ""; // Clear previous messages
            try {
              await signOut(auth);
              this.authMessage = "Signed out successfully.";
              // onAuthStateChanged will set user to null and clear data
            } catch (error) {
              this.authMessage = `Error signing out: ${error.message}`;
              console.error("Sign out error:", error);
            }
          },
          // --- END NEW AUTHENTICATION METHODS ---

          formatTime(seconds, includeHours = false) {
            if (seconds === 0 || isNaN(seconds)) return "00:00";
            const hrs = Math.floor(seconds / 3600);
            const mins = Math.floor((seconds % 3600) / 60);
            const secs = Math.floor(seconds % 60);
            if (includeHours || hrs > 0) {
              return `${hrs.toString().padStart(2, "0")}:${mins
                .toString()
                .padStart(2, "0")}:${secs.toString().padStart(2, "0")}`;
            }
            return `${mins.toString().padStart(2, "0")}:${secs
              .toString()
              .padStart(2, "0")}`;
          },
          calculateDistance(lat1, lon1, lat2, lon2) {
            const R = 3958.8; // Radius of Earth in miles
            const dLat = ((lat2 - lat1) * Math.PI) / 180;
            const dLon = ((lon2 - lon1) * Math.PI) / 180;
            const a =
              Math.sin(dLat / 2) * Math.sin(dLat / 2) +
              Math.cos((lat1 * Math.PI) / 180) *
                Math.cos((lat2 * Math.PI) / 180) *
                Math.sin(dLon / 2) *
                Math.sin(dLon / 2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
            return R * c;
          },
          startWorkout() {
            if ("vibrate" in navigator) navigator.vibrate(50);
            if (!this.isTracking && navigator.geolocation) {
              this.isTracking = true;
              this.startTime = Date.now();
              this.currentDistance = 0;
              this.lastPosition = null;
              this.watchId = navigator.geolocation.watchPosition(
                (position) => {
                  const { latitude, longitude } = position.coords;
                  if (this.lastPosition) {
                    const dist = this.calculateDistance(
                      this.lastPosition.latitude,
                      this.lastPosition.longitude,
                      latitude,
                      longitude
                    );
                    this.currentDistance += dist;
                  }
                  this.lastPosition = { latitude, longitude };
                  const elapsedSeconds = (Date.now() - this.startTime) / 1000;
                  this.currentPace =
                    this.currentDistance > 0
                      ? elapsedSeconds / this.currentDistance
                      : 0;
                },
                (error) => {
                  alert("Geolocation error: " + error.message);
                  this.stopWorkout();
                },
                { enableHighAccuracy: true, maximumAge: 0, timeout: 15000 }
              );
            } else if (!navigator.geolocation) {
              alert("Geolocation is not supported by this browser.");
            }
          },
          async stopWorkout() {
            if ("vibrate" in navigator) navigator.vibrate(50);
            if (this.watchId) {
              navigator.geolocation.clearWatch(this.watchId);
            }
            this.isTracking = false;
            if (this.currentDistance > 0) {
              const workoutTime = (Date.now() - this.startTime) / 1000;
              const oldTotalDistance = this.totalDistance;
              const oldTotalTime = this.totalTime;
              const oldXp = this.xp;

              if (this.user) {
                const newRunData = {
                  userId: this.user.uid,
                  date: new Date().toISOString(),
                  distance: this.currentDistance,
                  time: workoutTime,
                  pace: workoutTime / this.currentDistance,
                  timestamp: new Date(),
                };
                await addDoc(collection(db, "runs"), newRunData);

                this.totalDistance += this.currentDistance;
                this.totalTime += workoutTime;
                this.xp += this.currentDistance;

                await this.updateUserStatsInFirestore();

                this.animateStat(
                  "totalDistance",
                  oldTotalDistance,
                  this.totalDistance
                );
                this.animateStat("totalTime", oldTotalTime, this.totalTime);
                this.animateStat("xp", oldXp, this.xp);

                await nextTick();
                this.scrollToTop();

                this.fetchUserRuns(this.user.uid);

                if (Notification.permission === "granted") {
                  new Notification("Workout Complete!", {
                    body: `You ran ${this.currentDistance.toFixed(2)} miles!`,
                    icon: "/icons/boot.svg",
                  });
                } else if (Notification.permission !== "denied") {
                  Notification.requestPermission();
                }
              } else {
                alert("Please log in to save your workout data.");
              }
            }
            this.currentDistance = 0;
            this.currentPace = 0;
            this.lastPosition = null;
            this.startTime = null;
          },
          async logRun() {
            if ("vibrate" in navigator) navigator.vibrate(50);
            if (!this.user) {
              alert("Please log in to log a run.");
              return;
            }

            const dist = parseFloat(this.distanceInput);
            const hours = parseInt(this.hoursInput) || 0;
            const minutes = parseInt(this.minutesInput) || 0;
            const seconds = parseInt(this.secondsInput) || 0;
            const timeInSeconds = hours * 3600 + minutes * 60 + seconds;

            if (dist > 0 && timeInSeconds > 0) {
              const oldTotalDistance = this.totalDistance;
              const oldTotalTime = this.totalTime;
              const oldXp = this.xp;

              const newRunData = {
                userId: this.user.uid,
                date: new Date().toISOString(),
                distance: dist,
                time: timeInSeconds,
                pace: timeInSeconds / dist,
                timestamp: new Date(),
              };
              await addDoc(collection(db, "runs"), newRunData);

              this.totalDistance += dist;
              this.totalTime += timeInSeconds;
              this.xp += dist;

              await this.updateUserStatsInFirestore();

              this.animateStat(
                "totalDistance",
                oldTotalDistance,
                this.totalDistance
              );
              this.animateStat("totalTime", oldTotalTime, this.totalTime);
              this.animateStat("xp", oldXp, this.xp);

              this.distanceInput = null;
              this.hoursInput = null;
              this.minutesInput = null;
              this.secondsInput = null;

              await nextTick();
              this.scrollToTop();

              this.fetchUserRuns(this.user.uid);
            } else {
              alert(
                "Please enter a valid distance (miles) and time (all fields)."
              );
            }
          },
          async deleteRun(index) {
            if (!this.user) {
              alert("Please log in to delete runs.");
              return;
            }

            if (confirm("Are you sure you want to delete this run?")) {
              const runToDelete = this.runHistory[index];

              if (runToDelete.id) {
                await deleteDoc(doc(db, "runs", runToDelete.id));

                const oldTotalDistance = this.totalDistance;
                const oldTotalTime = this.totalTime;
                const oldXp = this.xp;

                this.totalDistance -= runToDelete.distance;
                this.totalTime -= runToDelete.time;
                this.xp -= runToDelete.distance;

                await this.updateUserStatsInFirestore();

                this.animateStat(
                  "totalDistance",
                  oldTotalDistance,
                  this.totalDistance
                );
                this.animateStat("totalTime", oldTotalTime, this.totalTime);
                this.animateStat("xp", oldXp, this.xp);

                this.runHistory.splice(index, 1);

                await nextTick();
                this.scrollToTop();

                if ("vibrate" in navigator) navigator.vibrate(50);
              } else {
                alert("Error: Run ID not found for deletion.");
              }
            }
          },

          async fetchUserRuns(userId) {
            if (!userId) {
              this.runHistory = [];
              return;
            }
            try {
              const q = query(
                collection(db, "runs"),
                where("userId", "==", userId)
              );
              const querySnapshot = await getDocs(q);
              this.runHistory = querySnapshot.docs
                .map((doc) => ({
                  id: doc.id,
                  ...doc.data(),
                  date: doc.data().date,
                  timestamp: doc.data().timestamp.toDate(),
                }))
                .sort((a, b) => b.timestamp - a.timestamp);
            } catch (error) {
              console.error("Error fetching runs:", error);
            }
          },

          async loadUserStats(userId) {
            if (!userId) {
              this.totalDistance = 0;
              this.totalTime = 0;
              this.xp = 0;
              this.animatedTotalDistance = 0;
              this.animatedTotalTime = 0;
              this.animatedXp = 0;
              return;
            }
            try {
              const userStatsDocRef = doc(db, "userStats", userId);
              const userStatsDoc = await getDoc(userStatsDocRef); // Corrected: Use getDoc

              if (userStatsDoc.exists()) {
                const data = userStatsDoc.data();
                this.totalDistance = data.totalDistance || 0;
                this.totalTime = data.totalTime || 0;
                this.xp = data.xp || 0;
              } else {
                this.totalDistance = 0;
                this.totalTime = 0;
                this.xp = 0;
                await setDoc(userStatsDocRef, {
                  totalDistance: 0,
                  totalTime: 0,
                  xp: 0,
                });
              }
              this.animatedTotalDistance = this.totalDistance;
              this.animatedTotalTime = this.totalTime;
              this.animatedXp = this.xp;
            } catch (error) {
              console.error("Error loading user stats:", error);
            }
          },

          async updateUserStatsInFirestore() {
            if (!this.user) return;
            try {
              const userStatsDocRef = doc(db, "userStats", this.user.uid);
              await setDoc(
                userStatsDocRef,
                {
                  totalDistance: this.totalDistance,
                  totalTime: this.totalTime,
                  xp: this.xp,
                },
                { merge: true }
              );
            } catch (error) {
              console.error("Error updating user stats:", error);
            }
          },

          animateStat(statName, startValue, endValue) {
            let animatedPropName;
            if (statName === "totalDistance")
              animatedPropName = "animatedTotalDistance";
            else if (statName === "totalTime")
              animatedPropName = "animatedTotalTime";
            else if (statName === "xp") animatedPropName = "animatedXp";
            else return;

            gsap.killTweensOf(this[animatedPropName]);

            gsap.fromTo(
              this.$data,
              { [animatedPropName]: startValue },
              {
                [animatedPropName]: endValue,
                duration: 1.5,
                ease: "elastic.out(1, 0.5)",
              }
            );

            gsap.fromTo(
              this.$refs.statsCard,
              { scale: 1, y: 0 },
              {
                scale: 1.02,
                y: -5,
                duration: 0.2,
                ease: "power1.out",
                yoyo: true,
                repeat: 1,
              }
            );
          },

          scrollToTop() {
            this.$nextTick(() => {
              window.scrollTo({
                top: 0,
                behavior: "smooth",
              });
            });
          },

          async resetStats() {
            if ("vibrate" in navigator) navigator.vibrate(100);
            if (!this.user) {
              alert("Please log in to reset stats.");
              return;
            }

            if (
              confirm(
                "Are you sure you want to reset all stats? This cannot be undone!"
              )
            ) {
              const oldTotalDistance = this.totalDistance;
              const oldTotalTime = this.totalTime;
              const oldXp = this.xp;

              try {
                const q = query(
                  collection(db, "runs"),
                  where("userId", "==", this.user.uid)
                );
                const querySnapshot = await getDocs(q);
                const batch = writeBatch(db);
                querySnapshot.forEach((docSnap) => {
                  batch.delete(docSnap.ref);
                });
                await batch.commit();

                const userStatsDocRef = doc(db, "userStats", this.user.uid);
                await setDoc(userStatsDocRef, {
                  totalDistance: 0,
                  totalTime: 0,
                  xp: 0,
                });

                this.totalDistance = 0;
                this.totalTime = 0;
                this.xp = 0;
                this.runHistory = [];

                this.animateStat("totalDistance", oldTotalDistance, 0);
                this.animateStat("totalTime", oldTotalTime, 0);
                this.animateStat("xp", oldXp, 0);

                await nextTick();
                this.scrollToTop();

                alert("All stats and runs reset successfully!");
              } catch (error) {
                console.error("Error resetting stats:", error);
                alert(`Failed to reset stats: ${error.message}`);
              }
            }
          },
        },
        mounted() {
          // Listen for auth state changes
          onAuthStateChanged(auth, async (currentUser) => {
            this.user = currentUser;
            if (currentUser) {
              console.log("User logged in:", currentUser.uid);
              // Load user's stats and runs from Firestore
              await this.loadUserStats(currentUser.uid);
              await this.fetchUserRuns(currentUser.uid);
            } else {
              console.log("User logged out.");
              // Clear local state if user logs out
              this.user = null;
              this.email = "";
              this.password = "";
              this.authMessage = "";
              this.totalDistance = 0;
              this.totalTime = 0;
              this.xp = 0;
              this.animatedTotalDistance = 0;
              this.animatedTotalTime = 0;
              this.animatedXp = 0;
              this.runHistory = [];
            }
          });

          if (
            Notification.permission !== "granted" &&
            Notification.permission !== "denied"
          ) {
            Notification.requestPermission();
          }
        },
      }).mount("#app");
    </script>
  </body>
</html>
